-------------------------------- MODULE TraceMultiNodeReads -------------------------------
EXTENDS MultiNodeReads, Json, IOUtils, Sequences

\* Trace validation has been designed for TLC running in default model-checking
\* mode, i.e., breadth-first search.
ASSUME TLCGet("config").mode = "bfs"

\* Note the extra /../ necessary to run in the VSCode extension but not a happy CLI default
JsonFile ==
    IF "JSON" \in DOMAIN IOEnv THEN IOEnv.JSON ELSE "../../build/consistency_trace.ndjson"

JsonLog ==
    \* Deserialize the System log as a sequence of records from the log file.
    \* Run TLC from under the tla/ directory with:
    \* $ JSON=../build/consistency_trace.ndjson ./tlc.sh consistency/TraceMultiNodeReads.tla
    \* Traces can be generated by running ./tests.sh -VV -R consistency_trace_validation under build/
    ndJsonDeserialize(JsonFile)

VARIABLE l

TraceInit ==
    /\ l = 1
    /\ Init

logline ==
    JsonLog[l]

ToTxType ==
    "RwTxRequest" :> RwTxRequest @@
    "RwTxResponse" :>  RwTxResponse @@
    "TxStatusReceived" :> TxStatusReceived

\* Beware to only prime e.g. inbox in inbox'[rcv] and *not* also rcv, i.e.,
 \* inbox[rcv]'.  rcv is defined in terms of TLCGet("level") that correctly
 \* handles priming, which causes for rcv' to equal rcv of the next log line.
IsEvent(e) ==
    \* Equals FALSE if we get past the end of the log, causing model checking to stop.
    /\ l \in 1..Len(JsonLog)
    /\ logline.action = e
    /\ l' = l + 1

IsRwTxRequestAction ==
    /\ IsEvent("RwTxRequestAction")
    /\ RwTxRequestAction
    /\ history'[Len(history')].type = ToTxType[logline.type]
    /\ history'[Len(history')].tx = logline.tx

IsRwTxExecuteAction ==
    /\ IsEvent("RwTxExecuteAction")
    /\ RwTxExecuteAction
    /\ history'[Len(history')].tx = logline.tx
    \* TODO: check view

IsRwTxResponseAction ==
    /\ IsEvent("RwTxResponseAction")
    /\ RwTxResponseAction
    /\ history'[Len(history')].type = ToTxType[logline.type]
    /\ history'[Len(history')].tx = logline.tx
    \* TODO: check view and seqno

IsStatusCommittedResponseAction ==
    /\ IsEvent("StatusCommittedResponseAction")
    /\ StatusCommittedResponseAction
    /\ history'[Len(history')].type = ToTxType[logline.type]
    \* TODO: check view and seqno

TraceNext ==
    \/ IsRwTxRequestAction
    \/ IsRwTxExecuteAction
    \/ IsRwTxResponseAction
    \/ IsStatusCommittedResponseAction

TraceSpec ==
    TraceInit /\ [][TraceNext]_<<l, vars>>

-------------------------------------------------------------------------------------

Termination ==
    l = Len(JsonLog) => TLCSet("exit", TRUE)

TraceView ==
    \* A high-level state  s  can appear multiple times in a system trace.  Including the
     \* current level in TLC's view ensures that TLC will not stop model checking when  s
     \* appears the second time in the trace.  Put differently,  TraceView  causes TLC to
     \* consider  s_i  and s_j  , where  i  and  j  are the positions of  s  in the trace,
     \* to be different states.
    <<vars, l>>

-------------------------------------------------------------------------------------

\* The property TraceMatched below will be violated if TLC runs with more than a single worker.
ASSUME TLCGet("config").worker = 1

TraceMatched ==
    \* We force TLC to check TraceMatched as a temporal property because TLC checks temporal
    \* properties after generating all successor states of the current state, unlike
    \* invariants that are checked after generating a successor state.
    \* If the queue is empty after generating all successors of the current state,
    \* and l is less than the length of the trace, then TLC failed to validate the trace.
    \*
    \* Note: Consider strengthening (Nat \ {0}) to {1} when validating traces with no nondeterminism.
    [](l <= Len(JsonLog) => [](TLCGet("queue") \in Nat \ {0} \/ l > Len(JsonLog)))

TraceMatchedNonTrivially ==
    \* If, e.g., the FALSE state constraint excludes all states, TraceMatched won't be violated.
    TLCGet("stats").diameter = Len(JsonLog)

MNR == INSTANCE MultiNodeReads

MNRSpec == MNR!SpecMultiNodeReads

==================================================================================
