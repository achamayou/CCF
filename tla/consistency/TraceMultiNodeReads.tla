-------------------------------- MODULE TraceMultiNodeReads -------------------------------
EXTENDS MultiNodeReads, Json, IOUtils, Sequences, SequencesExt

\* Trace validation has been designed for TLC running in default model-checking
\* mode, i.e., breadth-first search.
\* The property TraceMatched will be violated if TLC runs with more than a single worker.
ASSUME TLCGet("config").mode = "bfs" /\ TLCGet("config").worker = 1 /\ TLCSet(0, 0)

\* Note the extra /../ necessary to run in the VSCode extension but not a happy CLI default
JsonFile ==
    IF "JSON" \in DOMAIN IOEnv THEN IOEnv.JSON ELSE "trace.ndjson"

JsonLog ==
    \* Deserialize the System log as a sequence of records from the log file.
    \* Run TLC from under the tla/ directory with:
    \* $ JSON=../build/consistency/trace.ndjson ./tlc.sh consistency/TraceMultiNodeReads.tla
    \* Traces can be generated by running ./tests.sh -VV -R consistency_trace_validation under build/
    \* The clients execute transactions sequentially, and so the log is ordered by tx
    ndJsonDeserialize(JsonFile)

VARIABLE l

TraceInit ==
    /\ l = 1
    /\ Init

logline ==
    JsonLog[l]

ToTxType ==
    "RwTxRequest" :> RwTxRequest @@
    "RwTxResponse" :>  RwTxResponse @@
    "TxStatusReceived" :> TxStatusReceived @@
    "RoTxRequest" :> RoTxRequest @@
    "RoTxResponse" :>  RoTxResponse

ToStatus ==
    "CommittedStatus" :> CommittedStatus @@
    "InvalidStatus" :>  InvalidStatus

\* Beware to only prime e.g. inbox in inbox'[rcv] and *not* also rcv, i.e.,
 \* inbox[rcv]'.  rcv is defined in terms of TLCGet("level") that correctly
 \* handles priming, which causes rcv' to equal rcv of the next log line.
IsEvent(e) ==
    \* Equals FALSE if we get past the end of the log, causing model checking to stop.
    /\ l \in 1..Len(JsonLog)
    /\ logline.action = e
    /\ l' = l + 1
    /\ TLCSet(0, Max({l', TLCGet(0)}))

IsRwTxRequestAction ==
    /\ IsEvent("RwTxRequestAction")
    /\ RwTxRequestAction
    /\ Last(history').type = ToTxType[logline.type]
    /\ Last(history').tx = logline.tx

IsRwTxExecuteAction ==
    /\ IsEvent("RwTxExecuteAction")
    /\ RwTxExecuteAction
    /\ Last(history').tx = logline.tx
    \* RwTxExecuteAction can only take place if a branch exists for the view
    /\ Len(ledgerBranches) >= logline.tx_id[1]
    \* and that branch contains just the right amount of transactions (seqno - 1)
    /\ Len(ledgerBranches[logline.tx_id[1]]) = logline.tx_id[2] - 1

IsRwTxResponseAction ==
    /\ IsEvent("RwTxResponseAction")
    /\ RwTxResponseAction
    /\ Last(history').type = ToTxType[logline.type]
    /\ Last(history').tx = logline.tx
    /\ Last(history').tx_id = logline.tx_id

IsStatusCommittedResponseAction ==
    /\ IsEvent("StatusCommittedResponseAction")
    /\ StatusCommittedResponseAction
    /\ Last(history').type = ToTxType[logline.type]
    /\ Last(history').status = ToStatus[logline.status]
    /\ Last(history').tx_id = logline.tx_id

IsRoTxRequestAction ==
    /\ IsEvent("RoTxRequestAction")
    /\ RoTxRequestAction
    /\ Last(history').type = ToTxType[logline.type]
    /\ Last(history').tx = logline.tx

IsRoTxResponseAction ==
    /\ IsEvent("RoTxResponseAction")
    /\ RoTxResponseAction
    /\ Last(history').type = ToTxType[logline.type]
    \* RwTxExecuteAction can only take place if a branch exists for the view
    /\ Len(ledgerBranches) >= logline.tx_id[1]
    \* and that branch contains just the right amount of transactions (seqno - 1)
    /\ Len(ledgerBranches[logline.tx_id[1]]) = logline.tx_id[2] - 1

IsStatusInvalidResponseAction ==
    /\ IsEvent("StatusInvalidResponseAction")
    \* Cannot use StatusInvalidResponseAction directly, as it requires knowledge
    \* of an incompatible history state, which is not available at this point in the trace.
    /\ LET view == logline.tx_id[1]
           seqno == logline.tx_id[2]
       IN /\ Len(ledgerBranches) < seqno 
          /\ history' = Append(
             history, [
                type |-> ToTxType[logline.type],
                tx_id |-> logline.tx_id,
                status |-> ToStatus[logline.status]
             ]
            )
    /\ UNCHANGED <<ledgerBranches>>

\* Matches an event, but without advancing the log line. Useful to apply changes
\* before an event can be handled, for example backfilling the ledger branch, or
\* creating new ledger branches.
PreEvent(e) ==
    /\ l' = l
    /\ l \in 1..Len(JsonLog)
    /\ logline.action = e

BackfillLedgerBranch ==
    /\
        \/ PreEvent("RwTxExecuteAction")
        \* There is no separate RoTxExecuteAction, but conceptually,
        \* we would backfill before it as well. Instead we do before the
        \* RoTxResponseAction, which is the earliest possible opportunity.
        \/ PreEvent("RoTxResponseAction")
    \* Similar to AppendOtherTxnAction, but only append to the specific branch
    \* necessary to enable the next transaction to execute.
    /\ LET view == logline.tx_id[1]
           seqno == logline.tx_id[2]
       IN /\ Len(ledgerBranches) >= view
          /\ Len(ledgerBranches[view]) < seqno - 1
          /\ ledgerBranches' = [ledgerBranches EXCEPT ![view] = Append(@, [view |-> view])]
    /\ UNCHANGED history

\* Uses the the last_committed field, added on purpose in a new custom tx status endpoint,
\* to decide where to roll the ledger back to when we first see an Invalid.
RollbackLedgerBranch ==
    /\ PreEvent("StatusInvalidResponseAction")
    /\ LET view == logline.tx_id[1]
           seqno == logline.tx_id[2]
           lastCommittedSeqnoInView == logline.last_committed
       IN /\ Len(ledgerBranches) < view + 1
          /\ ledgerBranches' = Append(ledgerBranches, SubSeq(ledgerBranches[view], 1, lastCommittedSeqnoInView))
    /\ UNCHANGED history

\* Term may rev up by more than one post rollback, in which case we need to backfill
\* branches before we can backfill transactions in the new view with BackfillLedgerBranch
BackfillLedgerBranches ==
    /\ PreEvent("RwTxExecuteAction")
    /\ LET view == logline.tx_id[1]
           seqno == logline.tx_id[2]
       IN /\ Len(ledgerBranches) < view
          /\ ledgerBranches' = Append(ledgerBranches, Last(ledgerBranches))
    /\ UNCHANGED history

TraceNext ==
    \/ IsRwTxRequestAction
    \/ IsRwTxExecuteAction
    \/ IsRwTxResponseAction
    \/ IsStatusCommittedResponseAction
    \/ IsRoTxRequestAction
    \/ IsRoTxResponseAction
    \/ IsStatusInvalidResponseAction
    \/ BackfillLedgerBranch
    \/ RollbackLedgerBranch
    \/ BackfillLedgerBranches

TraceSpec ==
    TraceInit /\ [][TraceNext]_<<l, vars>>

-------------------------------------------------------------------------------------

Termination ==
    l = Len(JsonLog) => TLCSet("exit", TRUE)

-------------------------------------------------------------------------------------

TraceMatched ==
    \* We force TLC to check TraceMatched as a temporal property because TLC checks temporal
    \* properties after generating all successor states of the current state, unlike
    \* invariants that are checked after generating a successor state.
    \* If the queue is empty after generating all successors of the current state,
    \* and l is less than the length of the trace, then TLC failed to validate the trace.
    \*
    \* Note: Consider strengthening (Nat \ {0}) to {1} when validating traces with no nondeterminism.
    [](l <= Len(JsonLog) => [](TLCGet("queue") \in Nat \ {0} \/ l > Len(JsonLog)))

TraceMatchedNonTrivially ==
    \* If, e.g., the FALSE state constraint excludes all states, TraceMatched won't be violated.
    TLCGet(0) >= Len(JsonLog)

MNR == INSTANCE MultiNodeReads

MNRSpec == MNR!SpecMultiNodeReads

==================================================================================
